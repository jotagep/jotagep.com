---
title: 'JSON vs TOON: Ahorra tokens en tus LLMs ğŸª™'
slug: json-vs-toon-ahorra-tokens
publishedAt: 2025-11-20
cover: '../../../assets/posts/12/hero.png'
description: Descubre TOON, el nuevo formato que promete desbancar a JSON para alimentar a los LLMs y ahorrarte una fortuna en tokens.
isPublish: true
relatedPosts: ['el-stack-de-cloudflare', 'que-es-un-design-system-frontend']
translated: json-vs-toon-save-tokens
tags: ['ai']
objectContainImage: true
---

Â¡Hola a todos! ğŸ‘‹ Bienvenidos de nuevo al blog.

Hoy vengo a hablaros de un tema que estÃ¡ en boca de todos los que trabajamos con Inteligencia Artificial y LLMs (Large Language Models): **la optimizaciÃ³n de tokens**. Y es que, amigos, en el mundo de la IA, los tokens son dinero ğŸ’¸. Literalmente.

Si llevÃ¡is un tiempo "cacharreando" con modelos como GPT-4, Claude o Gemini, sabrÃ©is que alimentar a la bestia con datos estructurados es el pan de cada dÃ­a. Ya sea para RAG (Retrieval-Augmented Generation), para fine-tuning o simplemente para dar contexto, necesitamos pasarle datos al modelo. Y aquÃ­ es donde nuestro viejo amigo **JSON** ha sido el rey indiscutible... hasta ahora.

## El problema con JSON: La "tasa" de verbosidad ğŸ¢

No me malinterpretÃ©is, adoro JSON. Es legible, fÃ¡cil de parsear y universal. Ha sido el estÃ¡ndar de facto para el intercambio de datos en la web durante aÃ±os. Pero cuando se trata de enviar grandes cantidades de datos a un LLM, JSON tiene un "pequeÃ±o" problema: es **extremadamente verboso**.

Imaginad que tenÃ©is una lista de 1000 usuarios. En JSON, repetÃ­s las claves `name`, `email`, `role`, etc., Â¡1000 veces!

```json
{
  "users": [
    { "id": 1, "name": "Jorge", "role": "Developer", "active": true },
    { "id": 2, "name": "Maria", "role": "Designer", "active": false }
    // ... imagina esto repetido 1000 veces ğŸ˜±
  ]
}
```

Cada vez que repites `"name":`, estÃ¡s gastando tokens. Tokens que podrÃ­as estar usando para darle mÃ¡s contexto al modelo o para obtener una respuesta mÃ¡s larga. Es estructura redundante que el modelo no necesita ver constantemente para entender los datos.

## Â¿QuÃ© es TOON? ğŸ¦¸â€â™‚ï¸

AquÃ­ es donde entra en juego **TOON** (Token-Oriented Object Notation). Es un formato diseÃ±ado especÃ­ficamente para ser "token-friendly". Su objetivo es mantener la estructura de los datos pero eliminando la redundancia sintÃ¡ctica que tanto nos cuesta en la factura de la API.

Pensad en TOON como una **capa de traducciÃ³n**: usas JSON en tu cÃ³digo (porque es cÃ³modo), pero lo codificas a TOON antes de enviÃ¡rselo al LLM.

La filosofÃ­a de TOON es sencilla pero brillante: combina la estructura basada en indentaciÃ³n de **YAML** (para objetos anidados) con la eficiencia tabular de **CSV** (para arrays uniformes).

### Â¿CÃ³mo funciona?

La clave estÃ¡ en **declarar la estructura una sola vez** y luego hacer "streaming" de los datos.

Veamos el ejemplo anterior convertido a TOON:

```toon
users[2]{id,name,role,active}:
1,Jorge,Developer,true
2,Maria,Designer,false
```

Â¡Fijaos en la limpieza! ğŸ§¹

1.  **`users[2]`**: Declara explÃ­citamente la longitud del array. Esto ayuda al LLM a saber si se ha cortado la generaciÃ³n o si faltan datos.
2.  **`{id,name,role,active}`**: Define las cabeceras (las claves) una sola vez.
3.  **`1,Jorge...`**: Los datos van en filas, separados por comas, como en un CSV.

Hemos eliminado todas las comillas de las claves, las llaves repetitivas y las propias claves repetidas. Para un array de 2 elementos quizÃ¡s no parezca mucho, pero escalad esto a miles de registros y la diferencia es abismal.

## Un ejemplo mÃ¡s complejo: Lo mejor de dos mundos ğŸŒ

TOON no es solo un CSV glorificado. Su potencia real se ve cuando mezclamos objetos y arrays. Mirad este ejemplo sacado de su documentaciÃ³n oficial, donde tenemos un contexto (objeto) y listas de datos (arrays):

**En JSON:**

```json
{
  "context": {
    "task": "Nuestras excursiones favoritas",
    "location": "Pirineos",
    "season": "verano_2025"
  },
  "friends": ["ana", "luis", "sam"],
  "hikes": [
    { "id": 1, "name": "Monte Perdido", "km": 15.5, "hard": true },
    { "id": 2, "name": "Aneto", "km": 12.2, "hard": true },
    { "id": 3, "name": "Cola de Caballo", "km": 18.0, "hard": false }
  ]
}
```

**En TOON:**

```toon
context:
  task: Nuestras excursiones favoritas
  location: Pirineos
  season: verano_2025
friends[3]: ana,luis,sam
hikes[3]{id,name,km,hard}:
1,Monte Perdido,15.5,true
2,Aneto,12.2,true
3,Cola de Caballo,18.0,false
```

AquÃ­ vemos la magia:

- `context` usa un estilo tipo YAML (clave-valor con indentaciÃ³n).
- `friends` es un array de primitivos, super compacto.
- `hikes` es un array de objetos, que se renderiza como una tabla.

El formato se adapta automÃ¡ticamente a la estructura de tus datos para ser lo mÃ¡s eficiente posible.

## Â¿Por quÃ© usar TOON? (Design Goals) ğŸ¯

SegÃºn sus creadores, TOON tiene unos objetivos de diseÃ±o muy claros que lo hacen ideal para LLMs:

1.  **Eficiencia de Tokens**: Reduce el uso de tokens entre un **30% y un 60%** comparado con JSON pretty-printed.
2.  **Schema-Aware**: Al incluir la longitud del array `[N]` y las cabeceras, le damos pistas explÃ­citas al modelo. Esto reduce las alucinaciones y ayuda a validar que la salida estÃ¡ completa.
3.  **Legibilidad Humana**: A diferencia de formatos binarios o minificados al extremo, TOON sigue siendo legible por nosotros.
4.  **Lossless**: Es una representaciÃ³n sin pÃ©rdidas del modelo de datos JSON. Puedes ir de JSON -> TOON -> JSON sin perder nada.

## Â¿CuÃ¡ndo usarlo (y cuÃ¡ndo NO)? ğŸš¦

Como toda herramienta, no es una bala de plata. AquÃ­ os dejo mi recomendaciÃ³n:

### âœ… Ãšsalo cuando:

- Tengas **arrays uniformes de objetos** (listas de productos, usuarios, logs, transacciones). AquÃ­ es donde TOON brilla y destroza a JSON en eficiencia.
- El coste de los tokens sea una preocupaciÃ³n (Â¿y cuÃ¡ndo no lo es?).
- Necesites maximizar la ventana de contexto para meter mÃ¡s informaciÃ³n.

### âŒ No lo uses cuando:

- Tus datos sean **muy irregulares** o profundamente anidados sin patrones repetitivos. Si cada objeto tiene claves distintas, TOON no puede usar su formato tabular y acaba pareciÃ©ndose a YAML, perdiendo su ventaja.
- Necesites latencia ultra-baja en modelos locales muy pequeÃ±os que quizÃ¡s no han visto este formato nunca (aunque los modelos grandes lo entienden perfectamente con un prompt adecuado).
- Sean datos puramente tabulares y planos: ahÃ­ un simple CSV puede ser incluso mÃ¡s ligero (aunque TOON aÃ±ade seguridad con los tipos y longitudes).

## Benchmarks y Ahorro ğŸ“Š

Las pruebas preliminares son impresionantes. En datasets tÃ­picos de RAG, el ahorro es sustancial.

```
ğŸ›’ E-commerce orders with nested structures  â”Š  Tabular: 33%
   â”‚
   TOON                â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘    72,771 tokens
   â”œâ”€ vs JSON          (âˆ’33.1%)               108,806 tokens
   â”œâ”€ vs JSON compact  (+5.5%)                 68,975 tokens
   â”œâ”€ vs YAML          (âˆ’14.2%)                84,780 tokens
   â””â”€ vs XML           (âˆ’40.5%)               122,406 tokens

ğŸ§¾ Semi-uniform event logs  â”Š  Tabular: 50%
   â”‚
   TOON                â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘   153,211 tokens
   â”œâ”€ vs JSON          (âˆ’15.0%)               180,176 tokens
   â”œâ”€ vs JSON compact  (+19.9%)               127,731 tokens
   â”œâ”€ vs YAML          (âˆ’0.8%)                154,505 tokens
   â””â”€ vs XML           (âˆ’25.2%)               204,777 tokens

ğŸ§© Deeply nested configuration  â”Š  Tabular: 0%
   â”‚
   TOON                â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘       631 tokens
   â”œâ”€ vs JSON          (âˆ’31.3%)                   919 tokens
   â”œâ”€ vs JSON compact  (+11.9%)                   564 tokens
   â”œâ”€ vs YAML          (âˆ’6.2%)                    673 tokens
   â””â”€ vs XML           (âˆ’37.4%)                 1,008 tokens

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Total â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   TOON                â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘   226,613 tokens
   â”œâ”€ vs JSON          (âˆ’21.8%)               289,901 tokens
   â”œâ”€ vs JSON compact  (+14.9%)               197,270 tokens
   â”œâ”€ vs YAML          (âˆ’5.6%)                239,958 tokens
   â””â”€ vs XML           (âˆ’31.0%)               328,191 tokens
```

_Imaginad reducir vuestra factura de OpenAI o Anthropic a la mitad solo por cambiar el formato de los datos de entrada._ ğŸ¤¯

## ConclusiÃ³n

La optimizaciÃ³n es clave en esta nueva era de la IA. Herramientas como TOON nos ayudan a ser mÃ¡s eficientes y a construir mejores productos. No se trata solo de ahorrar dinero, sino de hacer que nuestras aplicaciones sean mÃ¡s rÃ¡pidas y capaces de procesar mÃ¡s informaciÃ³n.

TOON es todavÃ­a joven, pero su propuesta de valor es innegable. Si estÃ¡is construyendo aplicaciones intensivas en datos con LLMs, os animo a probarlo. PodÃ©is encontrar mÃ¡s informaciÃ³n y la documentaciÃ³n completa en su [pÃ¡gina oficial](https://toonformat.dev/).

Â¿Y vosotros? Â¿Ya habÃ©is probado formatos alternativos a JSON como YAML o XML para vuestros prompts? Â¡ContÃ¡dmelo en las redes!

Espero que os haya gustado este post y que os ayude a ahorrar unos cuantos tokens (y euros). ğŸ˜‰

Â¡Un saludo y nos vemos en el prÃ³ximo post! ğŸš€

Paz âœŒï¸.
